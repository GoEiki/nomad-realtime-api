{
  "version": 3,
  "sources": ["../../../../wavtools/lib/wav_packer.js", "../../../../wavtools/lib/analysis/constants.js", "../../../../wavtools/lib/analysis/audio_analysis.js", "../../../../wavtools/lib/worklets/stream_processor.js", "../../../../wavtools/lib/wav_stream_player.js", "../../../../wavtools/lib/worklets/audio_processor.js", "../../../../wavtools/lib/wav_recorder.js"],
  "sourcesContent": ["/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(\n      leftBuffer.byteLength + rightBuffer.byteLength\n    );\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [\n      new Uint8Array([arg, arg >> 8]),\n      new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24]),\n    ][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!audio?.bitsPerSample) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!audio?.channels) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!audio?.data) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const { bitsPerSample, channels, data } = audio;\n    const output = [\n      // Header\n      'RIFF',\n      this._packData(\n        1,\n        4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */\n      ), // Length\n      'WAVE',\n      // chunk 1\n      'fmt ', // Sub-chunk identifier\n      this._packData(1, 16), // Chunk length\n      this._packData(0, 1), // Audio format (1 is linear quantization)\n      this._packData(0, channels.length),\n      this._packData(1, sampleRate),\n      this._packData(1, (sampleRate * channels.length * bitsPerSample) / 8), // Byte rate\n      this._packData(0, (channels.length * bitsPerSample) / 8),\n      this._packData(0, bitsPerSample),\n      // chunk 2\n      'data', // Sub-chunk identifier\n      this._packData(\n        1,\n        (channels[0].length * channels.length * bitsPerSample) / 8\n      ), // Chunk length\n      data,\n    ];\n    const blob = new Blob(output, { type: 'audio/mpeg' });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2),\n    };\n  }\n}\n\nglobalThis.WavPacker = WavPacker;\n", "/**\n * Constants for help with visualization\n * Helps map frequency ranges from Fast Fourier Transform\n * to human-interpretable ranges, notably music ranges and\n * human vocal ranges.\n */\n\n// Eighth octave frequencies\nconst octave8Frequencies = [\n  4186.01, 4434.92, 4698.63, 4978.03, 5274.04, 5587.65, 5919.91, 6271.93,\n  6644.88, 7040.0, 7458.62, 7902.13,\n];\n\n// Labels for each of the above frequencies\nconst octave8FrequencyLabels = [\n  'C',\n  'C#',\n  'D',\n  'D#',\n  'E',\n  'F',\n  'F#',\n  'G',\n  'G#',\n  'A',\n  'A#',\n  'B',\n];\n\n/**\n * All note frequencies from 1st to 8th octave\n * in format \"A#8\" (A#, 8th octave)\n */\nexport const noteFrequencies = [];\nexport const noteFrequencyLabels = [];\nfor (let i = 1; i <= 8; i++) {\n  for (let f = 0; f < octave8Frequencies.length; f++) {\n    const freq = octave8Frequencies[f];\n    noteFrequencies.push(freq / Math.pow(2, 8 - i));\n    noteFrequencyLabels.push(octave8FrequencyLabels[f] + i);\n  }\n}\n\n/**\n * Subset of the note frequencies between 32 and 2000 Hz\n * 6 octave range: C1 to B6\n */\nconst voiceFrequencyRange = [32.0, 2000.0];\nexport const voiceFrequencies = noteFrequencies.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\nexport const voiceFrequencyLabels = noteFrequencyLabels.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\n", "import {\n  noteFrequencies,\n  noteFrequencyLabels,\n  voiceFrequencies,\n  voiceFrequencyLabels,\n} from './constants.js';\n\n/**\n * Output of AudioAnalysis for the frequency domain of the audio\n * @typedef {Object} AudioAnalysisOutputType\n * @property {Float32Array} values Amplitude of this frequency between {0, 1} inclusive\n * @property {number[]} frequencies Raw frequency bucket values\n * @property {string[]} labels Labels for the frequency bucket values\n */\n\n/**\n * Analyzes audio for visual output\n * @class\n */\nexport class AudioAnalysis {\n  /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  static getFrequencies(\n    analyser,\n    sampleRate,\n    fftResult,\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!fftResult) {\n      fftResult = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatFrequencyData(fftResult);\n    }\n    const nyquistFrequency = sampleRate / 2;\n    const frequencyStep = (1 / fftResult.length) * nyquistFrequency;\n    let outputValues;\n    let frequencies;\n    let labels;\n    if (analysisType === 'music' || analysisType === 'voice') {\n      const useFrequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n      for (let i = 0; i < fftResult.length; i++) {\n        const frequency = i * frequencyStep;\n        const amplitude = fftResult[i];\n        for (let n = useFrequencies.length - 1; n >= 0; n--) {\n          if (frequency > useFrequencies[n]) {\n            aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n            break;\n          }\n        }\n      }\n      outputValues = aggregateOutput;\n      frequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      labels =\n        analysisType === 'voice' ? voiceFrequencyLabels : noteFrequencyLabels;\n    } else {\n      outputValues = Array.from(fftResult);\n      frequencies = outputValues.map((_, i) => frequencyStep * i);\n      labels = frequencies.map((f) => `${f.toFixed(2)} Hz`);\n    }\n    // We normalize to {0, 1}\n    const normalizedOutput = outputValues.map((v) => {\n      return Math.max(\n        0,\n        Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1),\n      );\n    });\n    const values = new Float32Array(normalizedOutput);\n    return {\n      values,\n      frequencies,\n      labels,\n    };\n  }\n\n  /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */\n  constructor(audioElement, audioBuffer = null) {\n    this.fftResults = [];\n    if (audioBuffer) {\n      /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */\n      const { length, sampleRate } = audioBuffer;\n      const offlineAudioContext = new OfflineAudioContext({\n        length,\n        sampleRate,\n      });\n      const source = offlineAudioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      const analyser = offlineAudioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      source.connect(analyser);\n      // limit is :: 128 / sampleRate;\n      // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n      const renderQuantumInSeconds = 1 / 60;\n      const durationInSeconds = length / sampleRate;\n      const analyze = (index) => {\n        const suspendTime = renderQuantumInSeconds * index;\n        if (suspendTime < durationInSeconds) {\n          offlineAudioContext.suspend(suspendTime).then(() => {\n            const fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n            this.fftResults.push(fftResult);\n            analyze(index + 1);\n          });\n        }\n        if (index === 1) {\n          offlineAudioContext.startRendering();\n        } else {\n          offlineAudioContext.resume();\n        }\n      };\n      source.start(0);\n      analyze(1);\n      this.audio = audioElement;\n      this.context = offlineAudioContext;\n      this.analyser = analyser;\n      this.sampleRate = sampleRate;\n      this.audioBuffer = audioBuffer;\n    } else {\n      const audioContext = new AudioContext();\n      const track = audioContext.createMediaElementSource(audioElement);\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      track.connect(analyser);\n      analyser.connect(audioContext.destination);\n      this.audio = audioElement;\n      this.context = audioContext;\n      this.analyser = analyser;\n      this.sampleRate = this.context.sampleRate;\n      this.audioBuffer = null;\n    }\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    let fftResult = null;\n    if (this.audioBuffer && this.fftResults.length) {\n      const pct = this.audio.currentTime / this.audio.duration;\n      const index = Math.min(\n        (pct * this.fftResults.length) | 0,\n        this.fftResults.length - 1,\n      );\n      fftResult = this.fftResults[index];\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      fftResult,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */\n  async resumeIfSuspended() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    return true;\n  }\n}\n\nglobalThis.AudioAnalysis = AudioAnalysis;\n", "export const StreamProcessorWorklet = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\n\nconst script = new Blob([StreamProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const StreamProcessorSrc = src;\n", "import { StreamProcessorSrc } from './worklets/stream_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\n\n/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n * @class\n */\nexport class WavStreamPlayer {\n  /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */\n  constructor({ sampleRate = 44100 } = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.analyser) {\n      throw new Error('Not connected, please call .connect() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */\n  _start() {\n    const streamNode = new AudioWorkletNode(this.context, 'stream_processor');\n    streamNode.connect(this.context.destination);\n    streamNode.port.onmessage = (e) => {\n      const { event } = e.data;\n      if (event === 'stop') {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === 'offset') {\n        const { requestId, trackId, offset } = e.data;\n        const currentTime = offset / this.sampleRate;\n        this.trackSampleOffsets[requestId] = { trackId, offset, currentTime };\n      }\n    };\n    this.analyser.disconnect();\n    streamNode.connect(this.analyser);\n    this.stream = streamNode;\n    return true;\n  }\n\n  /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */\n  add16BitPCM(arrayBuffer, trackId = 'default') {\n    if (typeof trackId !== 'string') {\n      throw new Error(`trackId must be a string`);\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n    let buffer;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\n    }\n    this.stream.port.postMessage({ event: 'write', buffer, trackId });\n    return buffer;\n  }\n\n  /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async getTrackSampleOffset(interrupt = false) {\n    if (!this.stream) {\n      return null;\n    }\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? 'interrupt' : 'offset',\n      requestId,\n    });\n    let trackSampleOffset;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise((r) => setTimeout(() => r(), 1));\n    }\n    const { trackId } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n    return trackSampleOffset;\n  }\n\n  /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async interrupt() {\n    return this.getTrackSampleOffset(true);\n  }\n}\n\nglobalThis.WavStreamPlayer = WavStreamPlayer;\n", "const AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\n\nconst script = new Blob([AudioProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const AudioProcessorSrc = src;\n", "import { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`,\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`,\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`,\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`,\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback,\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = (devices) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone',\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput',\n    );\n    const defaultDeviceIndex = audioDevices.findIndex(\n      (device) => device.deviceId === 'default',\n    );\n    const deviceList = [];\n    if (defaultDeviceIndex !== -1) {\n      let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n      let existingIndex = audioDevices.findIndex(\n        (device) => device.groupId === defaultDevice.groupId,\n      );\n      if (existingIndex !== -1) {\n        defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n      }\n      defaultDevice.default = true;\n      deviceList.push(defaultDevice);\n    }\n    return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`,\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user media');\n    }\n    try {\n      const config = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      throw new Error('Could not start media stream');\n    }\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging',\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force',\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n"],
  "mappings": "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",
  "names": ["script", "src"]
}
